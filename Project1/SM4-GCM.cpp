#include <stdint.h>
#include <stdio.h>
#include <string.h>

// ---------------------------- 工具宏 ----------------------------
#define ROL32(x, n) (((x) << (n)) | ((x) >> (32 - (n))))

// ---------------------------- SM4 SBox ----------------------------
static const uint8_t SM4_SBOX[256] = {
    0xd6,0x90,0xe9,0xfe,0xcc,0xe1,0x3d,0xb7,0x16,0xb6,0x14,0xc2,0x28,0xfb,0x2c,0x05,
    0x2b,0x67,0x9a,0x76,0x2a,0xbe,0x04,0xc3,0xaa,0x44,0x13,0x26,0x49,0x86,0x06,0x99,
    0x9c,0x42,0x50,0xf4,0x91,0xef,0x98,0x7a,0x33,0x54,0x0b,0x43,0xed,0xcf,0xac,0x62,
    0xe4,0xb3,0x1c,0xa9,0xc9,0x08,0xe8,0x95,0x80,0xdf,0x94,0xfa,0x75,0x8f,0x3f,0xa6,
    0x47,0x07,0xa7,0xfc,0xf3,0x73,0x17,0xba,0x83,0x59,0x3c,0x19,0xe6,0x85,0x4f,0xa8,
    0x68,0x6b,0x81,0xb2,0x71,0x64,0xda,0x8b,0xf8,0xeb,0x0f,0x4b,0x70,0x56,0x9d,0x35,
    0x1e,0x24,0x0e,0x5e,0x63,0x58,0xd1,0xa2,0x25,0x22,0x7c,0x3b,0x01,0x21,0x78,0x87,
    0xd4,0x00,0x46,0x57,0x9f,0xd3,0x27,0x52,0x4c,0x36,0x02,0xe7,0xa0,0xc4,0xc8,0x9e,
    0xea,0xbf,0x8a,0xd2,0x40,0xc7,0x38,0xb5,0xa3,0xf7,0xf2,0xce,0xf9,0x61,0x15,0xa1,
    0xe0,0xae,0x5d,0xa4,0x9b,0x34,0x1a,0x55,0xad,0x93,0x32,0x30,0xf5,0x8c,0xb1,0xe3,
    0x1d,0xf6,0xe2,0x2e,0x82,0x66,0xca,0x60,0xc0,0x29,0x23,0xab,0x0d,0x53,0x4e,0x6f,
    0xd5,0xdb,0x37,0x45,0xde,0xfd,0x8e,0x2f,0x03,0xff,0x6a,0x72,0x6d,0x6c,0x5b,0x51,
    0x8d,0x1b,0xaf,0x92,0xbb,0xdd,0xbc,0x7f,0x11,0xd9,0x5c,0x41,0x1f,0x10,0x5a,0xd8,
    0x0a,0xc1,0x31,0x88,0xa5,0xcd,0x7b,0xbd,0x2d,0x74,0xd0,0x12,0xb8,0xe5,0xb4,0xb0,
    0x89,0x69,0x97,0x4a,0x0c,0x96,0x77,0x7e,0x65,0xb9,0xf1,0x09,0xc5,0x6e,0xc6,0x84,
    0x18,0xf0,0x7d,0xec,0x3a,0xdc,0x4d,0x20,0x79,0xee,0x5f,0x3e,0xd7,0xcb,0x39,0x48
};

// ---------------------------- SM4 核心函数 ----------------------------
uint32_t tau(uint32_t A) {
    uint8_t a[4] = {(A>>24)&0xFF, (A>>16)&0xFF, (A>>8)&0xFF, A&0xFF};
    for (int i=0;i<4;i++) a[i]=SM4_SBOX[a[i]];
    return (a[0]<<24)|(a[1]<<16)|(a[2]<<8)|a[3];
}

uint32_t L(uint32_t B) { return B ^ ROL32(B,2)^ROL32(B,10)^ROL32(B,18)^ROL32(B,24); }
uint32_t T(uint32_t x) { return L(tau(x)); }

void sm4_encrypt_block(const uint8_t in[16], uint8_t out[16], const uint32_t rk[32]) {
    uint32_t X[36];
    for(int i=0;i<4;i++)
        X[i] = ((uint32_t)in[4*i]<<24)|((uint32_t)in[4*i+1]<<16)|((uint32_t)in[4*i+2]<<8)|(uint32_t)in[4*i+3];
    for(int i=0;i<32;i++)
        X[i+4] = X[i]^T(X[i+1]^X[i+2]^X[i+3]^rk[i]);
    for(int i=0;i<4;i++){
        uint32_t B = X[35-i];
        out[4*i] = (B>>24)&0xFF; out[4*i+1] = (B>>16)&0xFF;
        out[4*i+2] = (B>>8)&0xFF; out[4*i+3] = B&0xFF;
    }
}

// ---------------------------- GF(2^128) 乘法 ----------------------------
void galois_mult(const uint8_t X[16], const uint8_t Y[16], uint8_t Z[16]) {
    uint8_t V[16], tmp[16];
    memcpy(V,Y,16);
    memset(Z,0,16);
    for(int i=0;i<16;i++){
        for(int j=7;j>=0;j--){
            if((X[i]>>j)&1){
                for(int k=0;k<16;k++) Z[k] ^= V[k];
            }
            int carry = V[15]&1;
            for(int k=15;k>0;k--) V[k] = (V[k]>>1)|((V[k-1]&1)<<7);
            V[0] >>=1;
            if(carry) V[0] ^= 0xe1; // GF(2^128)多项式
        }
    }
}

// ---------------------------- GCM 加密 ----------------------------
void sm4_gcm_encrypt(const uint8_t *plaintext, uint8_t *ciphertext, uint32_t len,
                     const uint32_t rk[32], const uint8_t iv[12],
                     const uint8_t aad[], uint32_t aad_len, uint8_t tag[16]) {

    uint8_t counter[16] = {0};
    memcpy(counter, iv, 12);
    counter[15] = 1;

    uint8_t H[16]={0};
    sm4_encrypt_block(H,H,rk); // H = SM4(K,0^128)

    // CTR 模式加密
    for(uint32_t i=0;i<len;i+=16){
        uint8_t block[16];
        sm4_encrypt_block(counter, block, rk);
        uint32_t blk_len = (i+16<=len)?16:len-i;
        for(uint32_t j=0;j<blk_len;j++)
            ciphertext[i+j] = plaintext[i+j]^block[j];
        // CTR++
        for(int k=15;k>=12;k--){ if(++counter[k]) break; }
    }

    // GHASH = Hash(AAD||Ciphertext)
    uint8_t ghash[16]={0};
    for(uint32_t i=0;i<aad_len;i+=16){
        uint8_t block[16]={0};
        uint32_t blk_len = (i+16<=aad_len)?16:aad_len-i;
        memcpy(block,aad+i,blk_len);
        for(int j=0;j<16;j++) ghash[j] ^= block[j];
        galois_mult(ghash,H,ghash);
    }
    for(uint32_t i=0;i<len;i+=16){
        uint8_t block[16]={0};
        uint32_t blk_len = (i+16<=len)?16:len-i;
        memcpy(block,ciphertext+i,blk_len);
        for(int j=0;j<16;j++) ghash[j] ^= block[j];
        galois_mult(ghash,H,ghash);
    }

    // TAG = GHASH ^ E_K(IV||0x00000001)
    uint8_t s[16]; sm4_encrypt_block(counter,s,rk);
    for(int i=0;i<16;i++) tag[i] = ghash[i]^s[i];
}


int main(){
    uint32_t rk[32]={0x01234567,0x89abcdef,0xfedcba98,0x76543210,
                     0x00112233,0x44556677,0x8899aabb,0xccddeeff,
                     0x10203040,0x50607080,0x90a0b0c0,0xd0e0f000,
                     0x11111111,0x22222222,0x33333333,0x44444444,
                     0x55555555,0x66666666,0x77777777,0x88888888,
                     0x99999999,0xaaaaaaaa,0xbbbbbbbb,0xcccccccc,
                     0xdddddddd,0xeeeeeeee,0xffffffff,0x00000000,
                     0x0f1e2d3c,0x4b5a6978,0x8695a4b3,0xc2d1e0f0};
    uint8_t plaintext[32]="Hello, this is SM4-GCM test!!";
    uint8_t ciphertext[32], tag[16];
    uint8_t iv[12]={0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b};
    uint8_t aad[16]="ExtraAuthData";

    sm4_gcm_encrypt(plaintext,ciphertext,32,rk,iv,aad,16,tag);

    printf("Ciphertext: ");
    for(int i=0;i<32;i++) printf("%02x ",ciphertext[i]);
    printf("\nTag: ");
    for(int i=0;i<16;i++) printf("%02x ",tag[i]);
    printf("\n");
    return 0;
}
