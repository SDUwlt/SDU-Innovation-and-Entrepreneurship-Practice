# SM3 实现与优化实验

## 项目简介
本项目围绕国密哈希算法 **SM3** 进行了从零实现到多级优化的全过程，同时实现了基于 SM3 的安全分析与应用：
1. **SM3 基础实现**：严格遵循 GM/T 0004-2012 标准，完成纯 C 版本实现。
2. **执行效率优化**：从基础版出发，逐步引入轻量级算法级优化（on-the-fly 消息扩展、常量预计算、循环展开、寄存器轮换），显著提升性能。
3. **Length Extension Attack**：利用 SM3 的 Merkle–Damgård 结构，实现长度扩展攻击的 PoC 代码。
4. **Merkle 树构建与证明**：基于 RFC6962 规范，使用 SM3 作为底层哈希算法构建大规模 Merkle 树，并生成存在性与不存在性证明。

---

## 1. SM3 基础实现

### 实现要点
- 严格按照国密标准的消息填充规则与压缩函数公式实现。
- 使用 32 位无符号整数进行循环移位与布尔运算。
- 代码结构分为：
  - `sm3_init`：初始化上下文（IV）
  - `sm3_update`：分块更新消息
  - `sm3_final`：消息填充并输出哈希值
  - `sm3_hash`：单调用版本

### 测试向量
使用 GM/T 0004-2012 附录 A 标准测试：
- 输入 `"abc"`  
  输出：66c7f0f462eeedd9d1f2d46bdc10e4e2


---

## 2. SM3 算法优化

### 优化方法
1. **消息扩展 on-the-fly**  
 - 不一次性生成 W[68] 和 W′[64]，在压缩过程中动态计算所需值，减少内存访问。
2. **Tj 常量预计算**  
 - 在初始化时生成 `Tj <<< (j & 31)` 表，避免循环中重复移位。
3. **循环展开**  
 - 将 64 轮分成每 4 轮一组展开，减少分支开销。
4. **寄存器轮换**  
 - 使用宏定义减少变量赋值次数，改善寄存器分配。

### 性能对比
在同一硬件平台下（编译选项 `-O3 -std=c99`）：
| 实现版本 | 吞吐量 (MB/s) |
|----------|--------------|
| 基础版   | 275 MB/s     |
| 优化版   | ~380–480 MB/s |

<img width="1400" height="163" alt="image" src="https://github.com/user-attachments/assets/6bd38e6c-a7f4-4f23-8eb9-a2e73243e5fe" />

此外，还可以面向 X86-64 进行进一步提速：

1.利用 lea 合并常量与多操作数加法，比如把 a+b+Tj 折成一条，减少端口压力。

2.BMI2 / 无副作用旋转：在需要右旋的场合用 rorx（或让编译器模式下生成），降低标志位相关的寄存器依赖。

3.SIMD 辅助消息扩展：pshufb 做大端换序与字节洗牌，palignr 拼接窗口，按附件给出的寄存器布局减少「拼接瓶颈」。

4.AVX-512：用 VPROLD 实现单指令循环左移；VPTERNLOGD 以真值表把 A^B^C、FF/ GG 等布尔表达式压成一条指令。

---

## 3. Length Extension Attack

### 原理
SM3 采用 **Merkle–Damgård 结构**，因此给定：
- 原始消息 `M`
- 其哈希值 `H(M)`
- 以及 `|M|`（字节长度）

攻击者可在未知 `M` 内容的情况下构造：
M || pad(M) || suffix
并计算其哈希值 `H(M || pad(M) || suffix)` 与合法计算结果一致。

### 实现
- 从原哈希值恢复中间状态（作为新 IV）。
- 重现原消息的填充 `pad(M)`。
- 接着压缩附加数据 `suffix`，得到伪造哈希。

### 实验设置
- 服务器端持有未知的 `secret`（长度 8 字节）。
  
- 已知消息：
comment=10&uid=1001&role=user

- 已知标签：
cdb1aee16314187b8542ffae791c40a04088fc20f65afd8c3b02acc11a2fe23b

- 攻击者希望追加：
&role=admin
即攻击者希望在不知 secret 的情况下，把 &role=admin 追加到消息末尾，让服务器验证通过。

- 攻击过程：
攻击者猜测 secret 长度为 8 字节（实际也是 8）。
根据已知的哈希状态和消息长度，重构 SM3 内部状态，并用 SM3 的 padding 规则继续计算追加部分的哈希。
生成伪造消息（包含原消息、SM3 的 padding，以及追加的数据）。
得到新的标签（Forged tag）：
ef26b5d9a3386f1ddff2867a506a41a85822d85e73e2f33095eebff9bd84165b

- 验证：
服务器用真正的 secret 对伪造消息重新计算 MAC。
得到的值和攻击者伪造的 tag 完全一致 → 攻击成功。

<img width="1562" height="788" alt="屏幕截图 2025-08-14 155026" src="https://github.com/user-attachments/assets/9cbbd335-93ed-401e-9f95-e77e181094ff" />

---

## 4. 基于 SM3 的 Merkle 树

### 设计
遵循 **RFC6962** 的域分离规则：
- 叶子哈希：
LeafHash = SM3(0x00 || leaf_data)

- 内部节点：
NodeHash = SM3(0x01 || left || right)


### 功能
- **构建**：支持 10 万叶节点的大规模 Merkle 树。
- **存在性证明**：生成从叶到根的兄弟节点路径（Audit Path）。
- **不存在性证明**：通过前驱/后继的存在性证明证明目标不在集合中。

### 实现说明
- 构造 100,000 个叶子节点：`leaf-00000000` ~ `leaf-00099999`。
- 叶子节点哈希：`SM3(leaf_data)`。
- 父节点哈希：`SM3(left_child_hash || right_child_hash)`。
- 
### 资源优化
- 构建时仅保留两层节点（滚动缓冲）节省内存。
- 支持多线程并行构建父节点层。

<img width="1517" height="311" alt="屏幕截图 2025-08-14 155045" src="https://github.com/user-attachments/assets/239190dc-8e9a-4372-b56e-116a9f9a1c65" />

从运行结果可以看出：
成功进行了三种验证，而且都正常通过：

1.构建 Merkle 树

- 生成了 100000 个叶子节点（名字形如 "leaf-000xxxxx"）。

- 打印的 Merkle root 是 47521cc73ccd4ebaeeeeae26f6379544e57ec94c88c065499380a748b840d084，这是树的顶层哈希。

2.成员证明（Inclusion proof）

- 测试了索引 43362 对应的叶子 "leaf-00043362"。

- proof_len=17 表示它需要 17 个兄弟节点哈希来从叶子推到根（符合大约 log2(100000) ≈ 17 的计算）。

- 验证结果是 OK，说明这个叶子确实在树中。

3.非成员证明（Non-membership proof）

- 检查了不存在的 "leaf-99999999"。

- 找到了它在排序中的左邻居 "leaf-00099999"，也有 17 层证明链，验证成功 (OK)。

-因为它应该排在最后一个叶子之后，所以没有右邻居（符合逻辑）。
