# SM3 实现与优化实验

## 项目简介
本项目围绕国密哈希算法 **SM3** 进行了从零实现到多级优化的全过程，同时实现了基于 SM3 的安全分析与应用：
1. **SM3 基础实现**：严格遵循 GM/T 0004-2012 标准，完成纯 C 版本实现。
2. **执行效率优化**：从基础版出发，逐步引入轻量级算法级优化（on-the-fly 消息扩展、常量预计算、循环展开、寄存器轮换），显著提升性能。
3. **Length Extension Attack**：利用 SM3 的 Merkle–Damgård 结构，实现长度扩展攻击的 PoC 代码。
4. **Merkle 树构建与证明**：基于 RFC6962 规范，使用 SM3 作为底层哈希算法构建大规模 Merkle 树，并生成存在性与不存在性证明。

---

## 1. SM3 基础实现

### 实现要点
- 严格按照国密标准的消息填充规则与压缩函数公式实现。
- 使用 32 位无符号整数进行循环移位与布尔运算。
- 代码结构分为：
  - `sm3_init`：初始化上下文（IV）
  - `sm3_update`：分块更新消息
  - `sm3_final`：消息填充并输出哈希值
  - `sm3_hash`：单调用版本

### 测试向量
使用 GM/T 0004-2012 附录 A 标准测试：
- 输入 `"abc"`  
  输出：66c7f0f462eeedd9d1f2d46bdc10e4e2


---

## 2. SM3 算法优化

### 优化方法
1. **消息扩展 on-the-fly**  
 - 不一次性生成 W[68] 和 W′[64]，在压缩过程中动态计算所需值，减少内存访问。
2. **Tj 常量预计算**  
 - 在初始化时生成 `Tj <<< (j & 31)` 表，避免循环中重复移位。
3. **循环展开**  
 - 将 64 轮分成每 4 轮一组展开，减少分支开销。
4. **寄存器轮换**  
 - 使用宏定义减少变量赋值次数，改善寄存器分配。

### 性能对比
在同一硬件平台下（编译选项 `-O3 -std=c99`）：
| 实现版本 | 吞吐量 (MB/s) |
|----------|--------------|
| 基础版   | 275 MB/s     |
| 优化版   | ~380–480 MB/s |

---

## 3. Length Extension Attack

### 原理
SM3 采用 **Merkle–Damgård 结构**，因此给定：
- 原始消息 `M`
- 其哈希值 `H(M)`
- 以及 `|M|`（字节长度）

攻击者可在未知 `M` 内容的情况下构造：

